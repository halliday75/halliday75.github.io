<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>King of Parking: Fluid Edition</title>
    <style>
        :root {
            --cell: min(75px, 13vmin);
            --grass: #3d5e20;
            --asphalt: #2c2c2c;
            --border-color: #111;
        }
        body {
            background: #111; color: white; font-family: 'Courier New', Courier, monospace;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; margin: 0; overflow: hidden; user-select: none;
            overscroll-behavior: none;
        }
        
        #game-container {
            background: var(--grass);
            padding: calc(var(--cell) * 0.5);
            border: clamp(6px, 1.5vmin, 12px) solid var(--border-color);
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
            position: relative;
            border-radius: 8px;
            z-index: 0;
        }
        
        #grid {
            width: calc(var(--cell) * 6); 
            height: calc(var(--cell) * 6);
            background: var(--asphalt);
            border: clamp(3px, 1vmin, 6px) solid var(--border-color);
            position: relative;
            z-index: 5;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc0JyBoZWlnaHQ9JzQnIHZpZXdCb3g9JzAgMCA0IDQnPgo8cGF0aCBZmlsbD0nIzAwMDAwMCcgb3BhY2l0eT0nMC4xJyBkPSdNMSAzaDF2MUgxVjN6bTItMmgxVjFIM3YxeicvPjwvc3ZnPg==');
        }

        .exit-gate {
            position: absolute;
            top: 33.333%;
            right: -14%;
            width: 14%; 
            height: 16.666%;
            background: var(--asphalt);
            border-top: clamp(3px, 1vmin, 6px) solid var(--border-color);
            border-bottom: clamp(3px, 1vmin, 6px) solid var(--border-color);
            z-index: 1; 
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc0JyBoZWlnaHQ9JzQnIHZpZXdCb3g9JzAgMCA0IDQnPgo8cGF0aCBZmlsbD0nIzAwMDAwMCcgb3BhY2l0eT0nMC4xJyBkPSdNMSAzaDF2MUgxVjN6bTItMmgxVjFIM3YxeicvPjwvc3ZnPg==');
        }
        
        .exit-gate::after {
            content: ''; position: absolute; left: -10%; top: 0; bottom: 0; width: 20%; background: var(--asphalt);
        }

        .car {
            position: absolute; 
            transition: left 0.3s cubic-bezier(0.45, 0.05, 0.55, 0.95), top 0.3s cubic-bezier(0.45, 0.05, 0.55, 0.95);
            cursor: pointer; box-sizing: border-box;
            border: 2px solid rgba(0,0,0,0.6);
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            border-radius: 15%;
            overflow: hidden;
            z-index: 10; 
            touch-action: none;
        }

        .car::before {
            content: ''; position: absolute;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .car::after {
            content: ''; position: absolute;
            background: rgba(255,255,255,0.15);
            border-radius: 4px;
        }

        .car.h::before { top: 15%; bottom: 15%; left: 15%; right: 40%; border-radius: 4px; }
        .car.h::after { top: 20%; bottom: 20%; right: 10%; width: 20%; }
        .car.v::before { left: 15%; right: 15%; top: 15%; bottom: 40%; border-radius: 4px; }
        .car.v::after { left: 20%; right: 20%; bottom: 10%; height: 20%; }

        .car.red { 
            background: linear-gradient(#f22, #900) !important; 
            border: 2px solid gold; 
            z-index: 20; 
        }
        .car.blue { background: linear-gradient(#33f, #006); }
        .car.green { background: linear-gradient(#3f3, #060); }
        
        #ui { 
            margin-bottom: 20px; 
            text-align: center; 
            width: 90%; 
            max-width: 500px; 
        }
        #status-msg { color: #555; font-weight: bold; height: 24px; margin-top: 10px; font-size: 0.8rem; }
        
        button { 
            background: gold; border: none; padding: 12px 24px; 
            font-weight: bold; cursor: pointer; border-radius: 4px; 
            color: black; box-shadow: 0 4px 0 #c90; 
            font-size: 1rem;
        }
        button:active { transform: translateY(2px); box-shadow: 0 2px 0 #c90; }
        .stat-line { font-size: 1.1rem; margin: 10px 0; color: #ccc; }
        span { color: gold; }

        @media (max-width: 600px) {
            #ui h1 { font-size: 1.5rem; }
            .stat-line { font-size: 0.9rem; }
            button { padding: 10px 16px; font-size: 0.9rem; }
            #ui { margin-bottom: 10px; }
        }
    </style>
</head>
<body>

<div id="ui">
    <h1 style="margin:0; color: gold; text-shadow: 2px 2px 4px #000;">KING OF PARKING</h1>
    <div class="stat-line">
        Moves: <span id="move-count">0</span> | 
        Complexity: <span id="diff-score">Pre-Loading...</span>
    </div>
    <button onclick="game.requestNewLevel()">GENERATE NEW PUZZLE</button>
    <div id="status-msg">Worker idle...</div>
</div>

<div id="game-container">
    <div id="grid">
        <div class="exit-gate"></div>
    </div>
</div>

<script id="worker-code" type="text/javascript-worker">
    self.onmessage = function(e) {
        const { iterations, targetDiff } = e.data;
        
        function getCarAt(x, y, cars) {
            return cars.find(c => {
                if (c.orient === 'h') return y === c.y && x >= c.x && x < c.x + c.len;
                return x === c.x && y >= c.y && y < c.y + c.len;
            });
        }

        function canMove(car, dir, cars) {
            const nx = dir === 1 ? (car.orient === 'h' ? car.x + car.len : car.x) : (car.orient === 'h' ? car.x - 1 : car.x);
            const ny = dir === 1 ? (car.orient === 'v' ? car.y + car.len : car.y) : (car.orient === 'v' ? car.y - 1 : car.y);
            if (car.type === 'red' && car.orient === 'h' && dir === 1 && nx >= 6) return true;
            if (nx < 0 || ny < 0 || nx >= 6 || ny >= 6) return false;
            return !getCarAt(nx, ny, cars);
        }

        function solve(startCars) {
            let queue = [{ state: JSON.stringify(startCars), steps: 0 }];
            let seen = new Set([queue[0].state]);
            let head = 0;
            while (head < queue.length) {
                let { state, steps } = queue[head++];
                let currentCars = JSON.parse(state);
                let red = currentCars.find(c => c.type === 'red');
                if (red.x === 4) return steps + 1; 
                if (steps > 32) continue; 
                for (let i = 0; i < currentCars.length; i++) {
                    let car = currentCars[i];
                    for (let dir of [-1, 1]) {
                        if (canMove(car, dir, currentCars)) {
                            let nextCars = JSON.parse(state);
                            nextCars[i].x += (nextCars[i].orient === 'h' ? dir : 0);
                            nextCars[i].y += (nextCars[i].orient === 'v' ? dir : 0);
                            let serialized = JSON.stringify(nextCars);
                            if (!seen.has(serialized)) {
                                seen.add(serialized);
                                queue.push({ state: serialized, steps: steps + 1 });
                            }
                        }
                    }
                }
            }
            return -1;
        }

        let bestBoard = null;
        let maxDiff = 0;

        for(let i=0; i < iterations; i++) {
            let testCars = [{id: 'red', x: 0, y: 2, len: 2, orient: 'h', type: 'red'}];
            for(let j=0; j<14; j++) {
                let orient = Math.random() > 0.5 ? 'h' : 'v';
                let len = Math.random() > 0.8 ? 3 : 2;
                let x = Math.floor(Math.random()*6), y = Math.floor(Math.random()*6);
                
                let blocked = false;
                if (orient === 'h' && x + len > 6) blocked = true;
                else if (orient === 'v' && y + len > 6) blocked = true;
                else {
                    for(let k=0; k<len; k++) {
                        if (getCarAt(orient === 'h' ? x+k : x, orient === 'v' ? y+k : y, testCars)) blocked = true;
                    }
                }
                if (!blocked) testCars.push({id: j, x, y, len, orient, type: j%2 === 0 ? 'blue' : 'green'});
            }
            let diff = solve(testCars);
            if (diff > maxDiff) { 
                maxDiff = diff; 
                bestBoard = testCars; 
                // Every time we find a new "best", send a preview to the main thread
                self.postMessage({ type: 'preview', cars: bestBoard, difficulty: maxDiff });
            }
            if (maxDiff >= targetDiff) break;
        }
        self.postMessage({ type: 'final', cars: bestBoard, difficulty: maxDiff });
    };
</script>

<script>
class ParkingGame {
    constructor() {
        this.cars = [];
        this.nextLevelBuffer = null;
        this.moves = 0;
        
        this.gridEl = document.getElementById('grid');
        this.moveEl = document.getElementById('move-count');
        this.diffEl = document.getElementById('diff-score');
        this.statusEl = document.getElementById('status-msg');

        const blob = new Blob([document.getElementById('worker-code').textContent], { type: 'text/javascript' });
        this.worker = new Worker(window.URL.createObjectURL(blob));
        
        this.worker.onmessage = (e) => {
            const { type, cars, difficulty } = e.data;
            this.nextLevelBuffer = { cars, difficulty };
</head>
<body>

<div id="ui">
    <h1 style="margin:0; color: gold;">KING OF PARKING</h1>
    <div class="stat-line">
        Moves: <span id="move-count">0</span> | Complexity: <span id="diff-score">14 moves</span>
    </div>
    <button onclick="game.requestNewLevel()">NEXT PUZZLE</button>
    <div id="status-msg">Worker idle...</div>
</div>

<div id="game-container">
    <div id="grid"><div class="exit-gate"></div></div>
</div>

<script id="worker-code" type="text/javascript-worker">
    self.onmessage = function(e) {
        const { iterations, targetDiff } = e.data;
        
        function solve(startCars) {
            let queue = [{ state: JSON.stringify(startCars), steps: 0 }];
            let seen = new Set([queue[0].state]);
            let head = 0;
            while (head < queue.length) {
                let { state, steps } = queue[head++];
                let currentCars = JSON.parse(state);
                let red = currentCars.find(c => c.type === 'red');
                if (red.x === 4) return steps + 1; 
                if (steps > 35) continue; 
                for (let i = 0; i < currentCars.length; i++) {
                    let car = currentCars[i];
                    for (let dir of [-1, 1]) {
                        const nx = dir === 1 ? (car.orient === 'h' ? car.x + car.len : car.x) : (car.orient === 'h' ? car.x - 1 : car.x);
                        const ny = dir === 1 ? (car.orient === 'v' ? car.y + car.len : car.y) : (car.orient === 'v' ? car.y - 1 : car.y);
                        let blocked = false;
                        if (car.type === 'red' && car.orient === 'h' && dir === 1 && nx >= 6) {}
                        else if (nx < 0 || ny < 0 || nx >= 6 || ny >= 6) blocked = true;
                        else {
                            blocked = currentCars.some(c => {
                                if (c.orient === 'h') return ny === c.y && nx >= c.x && nx < c.x + c.len;
                                return nx === c.x && ny >= c.y && ny < c.y + c.len;
                            });
                        }
                        if (!blocked) {
                            let nextCars = JSON.parse(state);
                            nextCars[i].x += (nextCars[i].orient === 'h' ? dir : 0);
                            nextCars[i].y += (nextCars[i].orient === 'v' ? dir : 0);
                            let serialized = JSON.stringify(nextCars);
                            if (!seen.has(serialized)) {
                                seen.add(serialized);
                                queue.push({ state: serialized, steps: steps + 1 });
                            }
                        }
                    }
                }
            }
            return -1;
        }

        let bestBoardForThisRun = null;
        let maxDiffForThisRun = 0;

        for(let i=0; i < iterations; i++) {
            let testCars = [{id: 'red', x: 0, y: 2, len: 2, orient: 'h', type: 'red'}];
            for(let j=0; j<14; j++) {
                let orient = Math.random() > 0.5 ? 'h' : 'v';
                let len = Math.random() > 0.8 ? 3 : 2;
                let x = Math.floor(Math.random()*6), y = Math.floor(Math.random()*6);
                let blocked = (orient === 'h' && x + len > 6) || (orient === 'v' && y + len > 6);
                if (!blocked) {
                    for(let k=0; k<len; k++) {
                        let curX = orient === 'h' ? x+k : x; let curY = orient === 'v' ? y+k : y;
                        if (testCars.some(c => {
                            if (c.orient === 'h') return curY === c.y && curX >= c.x && curX < c.x + c.len;
                            return curX === c.x && curY >= c.y && curY < c.y + c.len;
                        })) blocked = true;
                    }
                }
                if (!blocked) testCars.push({id: j, x, y, len, orient, type: j%2 === 0 ? 'blue' : 'green'});
            }

            let diff = solve(testCars);
            if (diff > maxDiffForThisRun) { 
                maxDiffForThisRun = diff; 
                bestBoardForThisRun = testCars; 
                self.postMessage({ type: 'found', cars: bestBoardForThisRun, difficulty: maxDiffForThisRun });
            }
            if (maxDiffForThisRun >= targetDiff) break;
        }
    };
</script>

<script>
class ParkingGame {
    constructor() {
        this.starterLevel = {
            difficulty: 14,
            cars: [
                {id: 'red', x: 0, y: 2, len: 2, orient: 'h', type: 'red'},
                {id: 0, x: 2, y: 0, len: 3, orient: 'v', type: 'blue'},
                {id: 1, x: 3, y: 2, len: 2, orient: 'v', type: 'green'},
                {id: 2, x: 0, y: 3, len: 2, orient: 'h', type: 'blue'},
                {id: 3, x: 5, y: 0, len: 3, orient: 'v', type: 'green'}
            ]
        };

        this.cars = [];
        this.nextLevelBuffer = null;
        this.moves = 0;
        this.gridEl = document.getElementById('grid');
        this.moveEl = document.getElementById('move-count');
        this.diffEl = document.getElementById('diff-score');
        this.statusEl = document.getElementById('status-msg');

        const blob = new Blob([document.getElementById('worker-code').textContent], { type: 'text/javascript' });
        this.worker = new Worker(window.URL.createObjectURL(blob));
        
        this.worker.onmessage = (e) => {
            const newLevel = e.data;
            // CRITICAL FIX: Only overwrite if the new puzzle is BETTER than the current buffer
            if (!this.nextLevelBuffer || newLevel.difficulty > this.nextLevelBuffer.difficulty) {
                this.nextLevelBuffer = newLevel;
                this.statusEl.innerText = `Buffer updated: ${newLevel.difficulty} moves locked.`;
            }
        };

        this.applyLevel(this.starterLevel);
        this.startWorker(800, 26); // High search depth
    }

    startWorker(iterations, targetDiff) {
        // We no longer nullify nextLevelBuffer here! We keep the old "best" until a "new best" arrives.
        this.worker.postMessage({ iterations, targetDiff });
    }

    requestNewLevel() {
        if (this.nextLevelBuffer) {
            this.applyLevel(this.nextLevelBuffer);
            this.nextLevelBuffer = null; // Clear it only once consumed
            this.startWorker(800, 28); 
        } else {
            this.statusEl.innerText = "Still searching for a complex puzzle...";
        }
    }

    applyLevel(levelData) {
        this.cars = JSON.parse(JSON.stringify(levelData.cars));
        this.moves = 0;
        this.diffEl.innerText = levelData.difficulty + " moves";
        this.moveEl.innerText = "0";
        document.querySelectorAll('.car').forEach(el => el.remove());
        this.render(true);
    }

    getCarAt(x, y) {
        return this.cars.find(c => {
            if (c.orient === 'h') return y === c.y && x >= c.x && x < c.x + c.len;
            return x === c.x && y >= c.y && y < c.y + c.len;
        });
    }

    canMove(car, dir) {
        const nx = dir === 1 ? (car.orient === 'h' ? car.x + car.len : car.x) : (car.orient === 'h' ? car.x - 1 : car.x);
        const ny = dir === 1 ? (car.orient === 'v' ? car.y + car.len : car.y) : (car.orient === 'v' ? car.y - 1 : car.y);
        if (car.type === 'red' && car.orient === 'h' && dir === 1 && nx >= 6) return true;
        if (nx < 0 || ny < 0 || nx >= 6 || ny >= 6) return false;
        return !this.getCarAt(nx, ny);
    }

    handleMove(car, dir) {
        let moved = false;
        if (car.type === 'red' && dir === 1) {
            let pathClear = true;
            for (let nextX = car.x + car.len; nextX < 6; nextX++) {
                if (this.getCarAt(nextX, car.y)) { pathClear = false; break; }
            }
            if (pathClear) {
                while (this.canMove(car, 1)) { car.x += 1; moved = true; if (car.x >= 6) break; }
            } else if (this.canMove(car, 1)) { car.x += 1; moved = true; }
        } else if (this.canMove(car, dir)) {
            car.x += (car.orient === 'h' ? dir : 0);
            car.y += (car.orient === 'v' ? dir : 0);
            moved = true;
        }

        if (moved) {
            this.moves++;
            this.moveEl.innerText = this.moves;
            this.render();
            if (car.type === 'red' && car.x >= 6) {
                setTimeout(() => { alert(`SOLVED!`); this.requestNewLevel(); }, 300);
            }
        }
    }

    render(forceNew = false) {
        this.cars.forEach(c => {
            let div = document.getElementById(`car-${c.id}`);
            if (!div || forceNew) {
                div = document.createElement('div');
                div.id = `car-${c.id}`;
                div.className = `car ${c.orient} ${c.type}`;
                div.style.width = (c.orient === 'h' ? c.len : 1) * 100/6 + '%';
                div.style.height = (c.orient === 'v' ? c.len : 1) * 100/6 + '%';
                const moveTrigger = (e) => {
                    const rect = div.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const offset = c.orient === 'h' ? clientX - rect.left : clientY - rect.top;
                    this.handleMove(c, offset > (c.len * (this.gridEl.clientWidth / 6)) / 2 ? 1 : -1);
                };
                div.onmousedown = (e) => { e.preventDefault(); moveTrigger(e); };
                div.ontouchstart = (e) => { if(e.cancelable) e.preventDefault(); moveTrigger(e); };
                this.gridEl.appendChild(div);
            }
            div.style.left = c.x * 100/6 + '%'; div.style.top = c.y * 100/6 + '%';
        });
    }
}
const game = new ParkingGame();
</script>
</body>
</html>
